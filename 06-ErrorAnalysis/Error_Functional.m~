function [err_Jh,err_Jh_AC]= Error_Functional(func_type,para,...
                                    mymesh,GQ1DRef_pts,GQ1DRef_wts,...
                                    Jh,Jh_AC)
    NGQ = length(GQ1DRef_pts);
    num_elements = mymesh.num_elements;
    
    if strcmp(func_type,'1')  % J(u) = (u,g)
        % need uexact, and source_g
        
        [uexact,source_g]=MyParaParse(para,'uexact','source_g');
        
        
        
        % Get Gauss Quadpoints on the square
        [a_list,b_list,Jacobian_rs_to_ab]= GetRefQuadPt(GQ1DRef_pts);
        % Map Gauss Quadpoints to the reference triangle
        [r_list,s_list] = ABtoRS(a_list,b_list);
        
        J_exact = 0.0;
        % compute (u,g) over the mesh elementes
        for element_idx = 1: num_elements
            
            temp_element = mymesh.element_list(element_idx,:);
            vertice_list = mymesh.vertices_list(temp_element(:),:);
            Jk = mymesh.Jacobian_list(element_idx);
            % Gauss points on any element
            [x_list,y_list] = RStoXY(r_list,s_list,Jk,vertice_list);

            g_VD = source_g([x_list,y_list]);
            g_VD = reshape(g_VD,[],NGQ);
            
            uexact_pts = uexact([x_list,y_list]);
            uexact_pts = reshape(uexact_pts,[],NGQ);
            
            J_exact = J_exact +...
                Jk*GQ1DRef_wts'*(g_VD.*uexact_pts.*Jacobian_rs_to_ab)*GQ1DRef_wts;  
            
        end
         % part 1: compute error J(u) - J(uh) and J(u) - Jh_AC 
         
         err_Jh = abs(J_exact - Jh);
         err_Jh_AC = abs(J_exact - Jh_AC);
              
    elseif strcmp(func_type,'2')  % J(u) = <-gradu * n,vD> = <q*n, vD>
        [qexact_1,qexact_2,vD]=MyParaParse(para,'qexact_1','qexact_2','vD');
        
        % go through all the faces, 
        % if it's a boundary face , do the integral
        
        num_faces = mymesh.num_faces;
        J_exact = 0.0;
        
        for element_idx = 1: num_elements
            ele_face_idx_list  = mymesh.element_faces_list(element_idx,:);
            for ii = 1:length(ele_face_idx_list)
                face_id = ele_face_idx_list(ii);
                bdry_flag = mymesh.f_type(face_id);
                if bdry_flag == 0
                    temp_element = mymesh.element_list(element_idx,:);
                    V1 = mymesh.vertices_list(ii,:);
                    if(ii==3)
                        V2_id = 1;
                    else
                        V2_id = ii+1;
                    end
                    V1 = mymesh.vertices_list(ii,:);
                end
                
            end
            temp_element = mymesh.element_list(element_idx,:);
            vertice_list = mymesh.vertices_list(temp_element(:),:);
            Jk = mymesh.Jacobian_list(element_idx);
        end
        
        for face_id = 1: num_faces
            bdry_flag = mymesh.f_type(face_id);
            if bdry_flag == 0
                face_vertices_id = mymesh.face_list(face_id,:);
                V1 = mymesh.vertices_list(face_vertices_id(1,1),:); 
                V2 = mymesh.vertices_list(face_vertices_id(1,2),:); 
                
                GQ_face_pts = 0.5*(V2-V1)*GQ1DRef_pts + 0.5*(V2+V1);
                q_face_pts1 = qexact_1(GQ_face_pts);
                q_face_pts2 = qexact_2(GQ_face_pts);
                
                vD_face_pts = vD(GQ_face_pts);
                
                % normal verctor n?
                
                temp_formula = (q_face_pts1*n(1) + q_face_pts2*n(2)).*vD_face_pts;
                face_length = VectorNorm(V1,V2);
                J_exact = J_exact  + 0.5 * face_length * GQ1DRef_wts' .* temp_formula;
                
            end
        end
        
        
        
        
        
        
    else
        error ('This type of error has not been implemented yet.')
    end
   
    
    
    
    
end