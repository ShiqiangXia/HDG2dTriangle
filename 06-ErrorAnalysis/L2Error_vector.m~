function [err,err_list] = L2Error_vector(mymesh,qh,...
                GQ1DRef_pts,GQ1DRef_wts,post_flag,...
                order,qexact_1,qexact_2)
            
            k = order;
            
            
            % call scalar L2 error 
            if post_flag == 0
                % since qh is (Pk,0) and (0,Pk)
                % we can split it as two scalar L2 errors
                % namely calculating qexact_1 - qh_1 and qexact_2 - qh_2
                Nu = (k+2)*(k+1)/2;
            
                qh_1 = qh(1:Nu,:);
                qh_2 = qh(Nu+1:end,:);
                
                [err1,err_list1] = L2Error_scalar(mymesh,qh_1,...
                    GQ1DRef_pts,GQ1DRef_wts,post_flag,...
                    order,qexact_1) ;

                [err2,err_list2] = L2Error_scalar(mymesh,qh_2,...
                    GQ1DRef_pts,GQ1DRef_wts,post_flag,...
                    order,qexact_2) ;

                err = sqrt((err1^2+err2^2));
                err_list = sqrt((err_list1.^2+err_list2.^2));
            elseif post_flag == 1
                % for this case. qh is in the Raviart-Thomas space Pk_vec + x*Pk_homo
                % we will just calculate the L2 error.
                [err1,err_list1] = L2Error_scalar(mymesh,qh,...
                    GQ1DRef_pts,GQ1DRef_wts,3,...
                    order,qexact_1) ;
                [err2,err_list2] = L2Error_scalar(mymesh,qh_2,...
                    GQ1DRef_pts,GQ1DRef_wts,post_flag,...
                    order,qexact_2) ;
                
                
            else
                error('Error calculation for this type of post-processing has not implemented. ')
            end
            
            
end

            